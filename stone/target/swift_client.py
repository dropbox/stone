from __future__ import absolute_import, division, print_function, unicode_literals

import argparse
import json
import os
import re

from contextlib import contextmanager

from stone.data_type import (
    is_struct_type,
    is_void_type,
)
from stone.target.swift import SwiftBaseGenerator
from stone.target.swift_helpers import (
    fmt_class,
    fmt_func,
    fmt_var,
    fmt_type,
)


auto_generated_warning = '/* Auto-generated by Stone, do not modify. */'

# This will be at the top of the generated file.
base = """\
{}

import Foundation
""".format(auto_generated_warning)

_cmdline_parser = argparse.ArgumentParser(
    prog='swift-client-generator',
    description=(
        'Generates a Swift class with an object for each namespace, and in each '
        'namespace object, a method for each route. This class assumes that the '
        'swift_types generator was used with the same output directory.'),
)
_cmdline_parser.add_argument(
    '-m',
    '--module-name',
    required=True,
    type=str,
    help=('The name of the Swift module to generate. Please exclude the .swift '
          'file extension.'),
)
_cmdline_parser.add_argument(
    '-c',
    '--class-name',
    required=True,
    type=str,
    help=('The name of the Swift class that contains an object for each namespace, '
          'and in each namespace object, a method for each route.')
)
_cmdline_parser.add_argument(
    '-t',
    '--transport-client-name',
    required=True,
    type=str,
    help='The name of the Swift class that managers network API calls.',
)
_cmdline_parser.add_argument(
    '-x',
    '--client-args-class-name',
    required=True,
    type=str,
    help='The name of the Swift class that contains each route as a method.',
)
_cmdline_parser.add_argument(
    '-y',
    '--client-args',
    required=True,
    type=str,
    help='The name of the Swift class that contains each route as a method.',
)


class SwiftGenerator(SwiftBaseGenerator):
    """Generates Swift client base that implements route interfaces."""
    cmdline_parser = _cmdline_parser

    def generate(self, api):
        client_args = json.loads(self.args.client_args)
        with self.output_to_relative_path('{}.swift'.format(self.args.client_args_class_name)):
            self._generate_client_args(client_args)

        rsrc_folder = os.path.join(os.path.dirname(__file__), 'swift_rsrc')
        for namespace in api.namespaces.values():
            ns_class = fmt_class(namespace.name)
            if namespace.routes:
                with self.output_to_relative_path('{}Routes.swift'.format(ns_class)):
                    self._generate_routes(namespace)

        with self.output_to_relative_path('{}.swift'.format(self.args.module_name)):
            self._generate_client(api)

    def _generate_client(self, api):
        self.emit_raw(base)
        self.emit('import Alamofire')

        self.emit('')
        with self.block('public class {}'.format(self.args.class_name)):
            namespace_fields = []
            for namespace in api.namespaces.values():
                if namespace.routes:
                    namespace_fields.append((namespace.name,
                                              fmt_class(namespace.name)))
            for var, typ in namespace_fields:
                self.emit('/// Routes within the {} namespace. '
                          'See {}Routes for details.'.format(var, typ))
                self.emit('public var {}: {}Routes!'.format(var, typ))

            self.emit('')
            with self.function_block('public init', args=self._func_args([('client', '{}'.format(self.args.transport_client_name))])):
                for var, typ in namespace_fields:
                    self.emit('self.{} = {}Routes(client: client)'.format(var, typ))

    def _generate_routes(self, namespace):
        ns_class = fmt_class(namespace.name)
        self.emit()
        self.emit(auto_generated_warning)
        self.emit()
        self.emit('/// Routes for the {} namespace'.format(namespace.name))
        with self.block('public class {}Routes'.format(ns_class)):
            self.emit('public let client: {}'.format(self.args.transport_client_name))
            args = [('client', '{}'.format(self.args.transport_client_name))]
            with self.function_block('init', self._func_args(args)):
                self.emit('self.client = client')

            for route in namespace.routes:
                self._generate_route(namespace, route)

    def _get_route_args(self, namespace, route):
        arg_type = fmt_type(route.arg_data_type)
        if is_struct_type(route.arg_data_type):
            arg_list = self._struct_init_args(route.arg_data_type, namespace=namespace)
            doc_list = [(fmt_var(f.name), self.process_doc(f.doc, self._docf))
                        for f in route.arg_data_type.fields if f.doc]
        else:
            arg_list = [] if is_void_type(route.arg_data_type) else [('request', arg_type)]
            doc_list = []
        return arg_list, doc_list

    def _emit_route(self, namespace, route, extra_args=None, extra_docs=None):
        arg_list, doc_list = self._get_route_args(namespace, route)
        extra_args = extra_args or []
        extra_docs = extra_docs or []

        arg_type = fmt_type(route.arg_data_type)
        func_name = fmt_func(route.name)

        self.emit('/**')
        if route.doc:
            route_doc = self.process_doc(route.doc, self._docf)
        else:
            route_doc = 'The {} route'.format(func_name)
        self.emit_wrapped_text(route_doc, prefix='    ', width=120)
        self.emit()
        for name, doc in doc_list + extra_docs:
            if not doc:
                doc = 'Undocumented'
            self.emit_wrapped_text('- parameter {}: {}'.format(name, doc), prefix='    ', width=120)
        self.emit()
        output = (' - returns: Through the response callback, the caller will ' +
                         'receive a `{}` object on success or a `{}` object on failure.')
        output = output.format(fmt_type(route.result_data_type),
                               fmt_type(route.error_data_type))
        self.emit_wrapped_text(output, prefix='    ', width=120)
        self.emit('*/')

        rtype = self.fmt_serial_type(route.result_data_type, is_obj=False)
        etype = self.fmt_serial_type(route.error_data_type, is_obj=False)
        func_args = [
            ('route', '{}.{}'.format(fmt_class(namespace.name), func_name)),
        ]

        client_args = []
        for name, value, typ in extra_args:
            arg_list.append((name, typ))
            func_args.append((name, value))
            client_args.append((name, value))

        style = fmt_class(route.attrs.get('style'))

        with self.function_block('public func {}'.format(func_name),
                                 args=self._func_args(arg_list, force_first=True),
                                 return_type='{}Request<{}, {}>'.format(style, rtype,
                                                                               etype)):
            self.emit('let route = {}.{}'.format(fmt_class(namespace.name), func_name))
            if is_struct_type(route.arg_data_type):
                args = [(name, name) for name, _ in self._struct_init_args(route.arg_data_type)]
                func_args += [('serverArgs', '{}({})'.format(arg_type, self._func_args(args)))]
                self.emit('let serverArgs = {}({})'.format(arg_type, self._func_args(args)))
            elif is_void_type(route.arg_data_type):
                func_args += [('serverArgs', '{}'.format('nil'))]
                self.emit('let serverArgs = {}'.format('nil'))

            func_args += [('clientArgs', '{}ClientArgs()'.format(style))]
            self.emit('let clientArgs = {}ClientArgs({})'.format(style, self._func_args(client_args)))
            self.emit('return client.request(route, serverArgs: serverArgs, clientArgs: clientArgs)')

    def _generate_route(self, namespace, route):
        route_type = route.attrs.get('style')
        client_args = json.loads(self.args.client_args)
        route_args = client_args[route_type]['route']

        for a, v in route_args.iteritems():
            extra_args = []
            for a, data in v.iteritems():
                extra_args.append(tuple(data))
            self._emit_route(namespace, route, extra_args, [])


    def _generate_client_args(self, client_args):
        self.emit_raw(base)

        for route_style, struct_map in client_args.iteritems():
            self.emit('')

            init_args = []
            with self.block('public class {}ClientArgs'.format(fmt_class(route_style))):
                for _, type_data in struct_map['class'].iteritems():
                    data = tuple(type_data)
                    init_args.append(data)
                    var, typ = data
                    stripped_typ = re.search('(.*) =', typ)
                    stripped_typ = typ if not stripped_typ else stripped_typ.group(1)
                    self.emit('public let {}: {}'.format(var, stripped_typ))

                self.emit('')

                with self.function_block('public init', args=self._func_args(init_args)):
                    for var, typ in init_args:
                        self.emit('self.{} = {}'.format(var, var))
