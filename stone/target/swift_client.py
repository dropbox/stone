from __future__ import absolute_import, division, print_function, unicode_literals

import argparse
import json
import os
import re

from contextlib import contextmanager

from stone.data_type import (
    is_struct_type,
    is_union_type,
    is_void_type,
)
from stone.target.swift import SwiftBaseGenerator
from stone.target.swift_helpers import (
    fmt_class,
    fmt_func,
    fmt_var,
    fmt_type,
)


auto_generated_warning = '/* Auto-generated by Stone, do not modify. */'

# This will be at the top of the generated file.
base = """\
{}

import Foundation
""".format(auto_generated_warning)

_cmdline_parser = argparse.ArgumentParser(
    prog='swift-client-generator',
    description=(
        'Generates a Swift class with an object for each namespace, and in each '
        'namespace object, a method for each route. This class assumes that the '
        'swift_types generator was used with the same output directory.'),
)
_cmdline_parser.add_argument(
    '-m',
    '--module-name',
    required=True,
    type=str,
    help=('The name of the Swift module to generate. Please exclude the .swift '
          'file extension.'),
)
_cmdline_parser.add_argument(
    '-c',
    '--class-name',
    required=True,
    type=str,
    help=('The name of the Swift class that contains an object for each namespace, '
          'and in each namespace object, a method for each route.')
)
_cmdline_parser.add_argument(
    '-t',
    '--transport-client-name',
    required=True,
    type=str,
    help='The name of the Swift class that manages network API calls.',
)
_cmdline_parser.add_argument(
    '-x',
    '--client-args-class-name',
    type=str,
    help='The name of the Swift wrapper class that contains client-side arguments.',
)
_cmdline_parser.add_argument(
    '-y',
    '--client-args-class',
    type=str,
    help='The instance variables of the Swift wrapper class that contains client-side arguments.',
)
_cmdline_parser.add_argument(
    '-z',
    '--client-args',
    required=True,
    type=str,
    help='The client-side route arguments to append to each route by style type.',
)


class SwiftGenerator(SwiftBaseGenerator):
    """Generates Swift client base that implements route interfaces."""
    cmdline_parser = _cmdline_parser

    def generate(self, api):
        if self.args.client_args_class and self.args.client_args_class_name:
            client_args = json.loads(self.args.client_args_class)
            with self.output_to_relative_path('{}.swift'.format(self.args.client_args_class_name)):
                self._generate_client_args(client_args)

        rsrc_folder = os.path.join(os.path.dirname(__file__), 'swift_rsrc')
        for namespace in api.namespaces.values():
            ns_class = fmt_class(namespace.name)
            if namespace.routes:
                with self.output_to_relative_path('{}Routes.swift'.format(ns_class)):
                    self._generate_routes(namespace)

        with self.output_to_relative_path('{}.swift'.format(self.args.module_name)):
            self._generate_client(api)

    def _generate_client(self, api):
        self.emit_raw(base)
        self.emit('import Alamofire')
        self.emit()

        with self.block('public class {}'.format(self.args.class_name)):
            namespace_fields = []
            for namespace in api.namespaces.values():
                if namespace.routes:
                    namespace_fields.append((namespace.name,
                                            fmt_class(namespace.name)))
            for var, typ in namespace_fields:
                self.emit('/// Routes within the {} namespace. '
                          'See {}Routes for details.'.format(var, typ))
                self.emit('public var {}: {}Routes!'.format(var, typ))
            self.emit()

            with self.function_block('public init', args=self._func_args([('client', '{}'.format(self.args.transport_client_name))])):
                for var, typ in namespace_fields:
                    self.emit('self.{} = {}Routes(client: client)'.format(var, typ))

    def _generate_routes(self, namespace):
        ns_class = fmt_class(namespace.name)
        self.emit()
        self.emit(auto_generated_warning)
        self.emit()
        self.emit('/// Routes for the {} namespace'.format(namespace.name))

        with self.block('public class {}Routes'.format(ns_class)):
            self.emit('public let client: {}'.format(self.args.transport_client_name))
            args = [('client', '{}'.format(self.args.transport_client_name))]
            
            with self.function_block('init', self._func_args(args)):
                self.emit('self.client = client')

            for route in namespace.routes:
                self._generate_route(namespace, route)

    def _get_route_args(self, namespace, route):
        arg_type = fmt_type(route.arg_data_type)
        if is_struct_type(route.arg_data_type):
            arg_list = self._struct_init_args(route.arg_data_type, namespace=namespace)
            doc_list = [(fmt_var(f.name), self.process_doc(f.doc, self._docf))
                        for f in route.arg_data_type.fields if f.doc]
        else:
            arg_list = [] if is_void_type(route.arg_data_type) else [('request', arg_type)]
            doc_list = []
        return arg_list, doc_list

    def _emit_route(self, namespace, route, extra_args=None, extra_docs=None):
        arg_list, doc_list = self._get_route_args(namespace, route)
        extra_args = extra_args or []
        extra_docs = extra_docs or []

        arg_type = fmt_type(route.arg_data_type)
        func_name = fmt_func(route.name)

        self.emit('/**')
        if route.doc:
            route_doc = self.process_doc(route.doc, self._docf)
        else:
            route_doc = 'The {} route'.format(func_name)
        self.emit_wrapped_text(route_doc, prefix='    ', width=120)
        self.emit()
        for name, doc in doc_list + extra_docs:
            if not doc:
                doc = 'Undocumented'
            self.emit_wrapped_text('- parameter {}: {}'.format(name, doc), prefix='    ', width=120)
        self.emit()
        output = (' - returns: Through the response callback, the caller will ' +
                         'receive a `{}` object on success or a `{}` object on failure.')
        output = output.format(fmt_type(route.result_data_type),
                               fmt_type(route.error_data_type))
        self.emit_wrapped_text(output, prefix='    ', width=120)
        self.emit('*/')

        rtype = self.fmt_serial_type(route.result_data_type)
        etype = self.fmt_serial_type(route.error_data_type)
        func_args = [
            ('route', '{}.{}'.format(fmt_class(namespace.name), func_name)),
        ]

        client_args = []
        for name, value, typ in extra_args:
            arg_list.append((name, typ))
            func_args.append((name, value))
            client_args.append((name, value))

        style = fmt_class(route.attrs.get('style'))

        with self.function_block('public func {}'.format(func_name),
                                 args=self._func_args(arg_list, force_first=True),
                                 return_type='{}Request<{}, {}>'.format(style, rtype,
                                                                               etype)):
            self.emit('let route = {}.{}'.format(fmt_class(namespace.name), func_name))
            if is_struct_type(route.arg_data_type):
                args = [(name, name) for name, _ in self._struct_init_args(route.arg_data_type)]
                func_args += [('serverArgs', '{}({})'.format(arg_type, self._func_args(args)))]
                self.emit('let serverArgs = {}({})'.format(arg_type, self._func_args(args)))
            elif is_union_type(route.arg_data_type):
                self.emit('let serverArgs = {}'.format('request'))

            return_args = [('', 'route')]

            if is_void_type(route.arg_data_type):
                return_args += [('serverArgs', 'nil')]
            else:
                return_args += [('serverArgs', 'serverArgs')]

            if client_args:
                return_args += [('clientArgs', 'clientArgs')]
                self.emit('let clientArgs = {}ClientArgs({})'.format(style, self._func_args(client_args)))
            else:
                return_args += [('clientArgs', 'nil')]

            self.emit('return client.request({})'.format(self._func_args(return_args, not_init=True)))

    # def _maybe_generate_deprecation_warning(self, route):
    #     if route.deprecated:
    #         msg = '{} is deprecated.'.format(route.name)
    #         if route.deprecated.by:
    #             msg += ' Use {}.'.format(route.deprecated.by.name)
    #         args = ["'{}'".format(msg), 'DeprecationWarning']
    #         self.generate_multiline_list(args, before='warnings.warn', delim=('(', ')'), compact=False)

    def _generate_route(self, namespace, route):
        route_type = route.attrs.get('style')
        client_args = json.loads(self.args.client_args)
        route_args = client_args[route_type]

        if not route_args:
            self._emit_route(namespace, route)
        else:
            for extra_args_set in route_args:
                extra_args = [tuple(arg_set) for arg_set in extra_args_set]
                self._emit_route(namespace, route, extra_args, [])

    def _generate_client_args(self, client_args):
        self.emit_raw(base)

        for route_style, class_data in client_args.iteritems():
            self.emit()

            init_args = []
            with self.block('public class {}ClientArgs'.format(fmt_class(route_style))):
                for instance_var_data in class_data:
                    data = tuple(instance_var_data)
                    init_args.append(data)
                    var, typ = data
                    stripped_typ = re.search('(.*) =', typ)
                    stripped_typ = typ if not stripped_typ else stripped_typ.group(1)
                    self.emit('public let {}: {}'.format(var, stripped_typ))

                self.emit()

                with self.function_block('public init', args=self._func_args(init_args)):
                    for var, typ in init_args:
                        self.emit('self.{} = {}'.format(var, var))
