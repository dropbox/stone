from __future__ import absolute_import, division, print_function, unicode_literals

import argparse
import os

from contextlib import contextmanager

from stone.data_type import (
    is_struct_type,
    is_void_type,
)
from stone.target.swift import SwiftBaseGenerator
from stone.target.swift_helpers import (
    fmt_class,
    fmt_func,
    fmt_var,
)

auto_generated_warning = '/* Auto-generated by Stone, do not modify. */'

# This will be at the top of the generated file.
base = """\
{}
import Foundation
""".format(auto_generated_warning)

_cmdline_parser = argparse.ArgumentParser(
    prog='swift-client-generator',
    description=(
        'Generates a Swift class with an object for each namespace, and in each '
        'object, a method for each route. This class assumes that the swift_types '
        'generator was used with the same output directory.'),
)
_cmdline_parser.add_argument(
    '-m',
    '--module-name',
    required=True,
    type=str,
    help=('The name of the Swift module to generate. Please exclude the .swift '
          'file extension.'),
)
_cmdline_parser.add_argument(
    '-c',
    '--class-name',
    required=True,
    type=str,
    help='The name of the Swift class that contains each route as a method.',
)

class SwiftGenerator(SwiftBaseGenerator):
    """Generates Swift client base that implements route interfaces."""
    cmdline_parser = _cmdline_parser

    def generate(self, api):
        rsrc_folder = os.path.join(os.path.dirname(__file__), 'swift_rsrc')

        for namespace in api.namespaces.values():
            ns_class = fmt_class(namespace.name)

            if namespace.routes:
                with self.output_to_relative_path('{}Routes.swift'.format(ns_class)):
                    self._generate_routes(namespace)

        with self.output_to_relative_path('{}.swift'.format(self.args.module_name)):
            self._generate_client(api)



    def _generate_client(self, api):
        self.emit_raw(base)
        self.emit('import Alamofire')

        self.emit('')
        with self.block('public class {}'.format(self.args.class_name)):
            # self.emit('/// Shared instance for convenience')
            # self.emit('public static var sharedClient: DropboxClient!')

            namespace_fields = []
            for namespace in api.namespaces.values():
                if namespace.routes:
                    namespace_fields.append((namespace.name,
                                              fmt_class(namespace.name)))
            for var, typ in namespace_fields:
                self.emit('/// Routes within the {} namespace. '
                          'See {}Routes for details.'.format(var, typ))
                self.emit('public var {}: {}Routes!'.format(var, typ))

            self.emit('')
            with self.function_block('public init', args=self._func_args([('client', 'TransportClient')])):
                for var, typ in namespace_fields:
                    self.emit('self.{} = {}Routes(client: client)'.format(var, typ))

    def _generate_routes(self, namespace):
        ns_class = fmt_class(namespace.name)
        self.emit()
        self.emit(auto_generated_warning)
        self.emit()
        self.emit('/// Routes for the {} namespace'.format(namespace.name))
        with self.block('public class {}Routes'.format(ns_class)):
            self.emit('public let client: TransportClient')
            args = [('client', 'TransportClient')]
            with self.function_block('init', self._func_args(args)):
                self.emit('self.client = client')

            for route in namespace.routes:
                self._generate_route(namespace, route)

    STYLE_MAPPING = {
        'rpc': 'Rpc',
        'upload': 'Upload',
        'download': 'Download',
    }

    def _get_route_args(self, namespace, route):
        arg_type = self.fmt_complex_type(route.arg_data_type)
        if is_struct_type(route.arg_data_type):
            arg_list = self._struct_init_args(route.arg_data_type, namespace=namespace)
            doc_list = [(fmt_var(f.name), self.process_doc(f.doc, self._docf))
                        for f in route.arg_data_type.fields if f.doc]
        else:
            arg_list = [] if is_void_type(route.arg_data_type) else [('request', arg_type)]
            doc_list = []
        return arg_list, doc_list

    def _emit_route(self, namespace, route, extra_args=None, extra_docs=None):
        arg_list, doc_list = self._get_route_args(namespace, route)
        extra_args = extra_args or []
        extra_docs = extra_docs or []

        arg_type = self.fmt_complex_type(route.arg_data_type)
        func_name = fmt_func(route.name)

        self.emit('/**')
        if route.doc:
            route_doc = self.process_doc(route.doc, self._docf)
        else:
            route_doc = 'The {} route'.format(func_name)
        self.emit_wrapped_text(route_doc, prefix='    ', width=120)
        self.emit()
        for name, doc in doc_list + extra_docs:
            if not doc:
                doc = 'Undocumented'
            self.emit_wrapped_text('- parameter {}: {}'.format(name, doc), prefix='    ', width=120)
        self.emit()
        output = (' - returns: Through the response callback, the caller will ' +
                         'receive a `{}` object on success or a `{}` object on failure.')
        output = output.format(self.fmt_complex_type(route.result_data_type),
                               self.fmt_complex_type(route.error_data_type))
        self.emit_wrapped_text(output, prefix='    ', width=120)
        self.emit('*/')
        route_type = self.STYLE_MAPPING[route.attrs.get('style')]

        rtype = self.fmt_complex_type(route.result_data_type,
                                         serializer=True)
        etype = self.fmt_complex_type(route.error_data_type,
                                         serializer=True)
        func_args = [
            ('client', 'self.client'),
            ('route', '{}.{}'.format(fmt_class(namespace.name), func_name)),
            ('params', '{}.serialize({})'.format(
                self._serializer_obj(route.arg_data_type),
                '' if is_void_type(route.arg_data_type) else 'request')),
            ('responseSerializer', self._serializer_obj(route.result_data_type)),
            ('errorSerializer', self._serializer_obj(route.error_data_type)),
        ]

        for name, typ, value in extra_args:
            arg_list.append((name, typ))
            func_args.append((name, value))

        with self.function_block('public func {}'.format(func_name),
                                 args=self._func_args(arg_list, force_first=True),
                                 return_type='Dropbox{}Request<{}, {}>'.format(route_type,
                                                                               rtype,
                                                                               etype)):
            if is_struct_type(route.arg_data_type):
                args = [(name, name) for name, _ in self._struct_init_args(route.arg_data_type)]
                self.emit('let request = {}({})'.format(arg_type, self._func_args(args)))

            self.emit('return Dropbox{}Request({})'.format(route_type, self._func_args(func_args)))

    def _generate_upload_route_bindings(self, namespace, route):
        for case, typ in (('.Data', 'NSData'),
                                ('.File', 'NSURL'),
                                ('.Stream', 'NSInputStream')):
            extra_args = [("body", typ, "{}(body)".format(case))]
            extra_docs = [("body", "The file to upload, as an {} object".format(typ))]

            self._emit_route(namespace, route, extra_args, extra_docs)

    def _generate_download_route_bindings(self, namespace, route):
        extra_args = [(
            'destination', '(NSURL, NSHTTPURLResponse) -> NSURL', 'destination',
        ), (
            'overwrite', 'Bool = false', 'overwrite',
        )]
        extra_docs = [(
            'destination',
            'A closure used to compute the destination, '
            + 'given the temporary file location and the response'
        ), (
            'overwrite',
            'A boolean to set behavior in the event of a naming conflict. `True` will '
            + 'overwrite conflicting file at destination. `False` will take no action (but '
            + 'if left unhandled in destination closure, an NSError will be thrown).'
        )]

        self._emit_route(namespace, route, extra_args, extra_docs)

    def _generate_route(self, namespace, route):
        route_type = route.attrs.get('style')
        if route_type == 'upload':
            self._generate_upload_route_bindings(namespace, route)
        elif route_type == 'download':
            self._generate_download_route_bindings(namespace, route)
        else:
            self._emit_route(namespace, route)
