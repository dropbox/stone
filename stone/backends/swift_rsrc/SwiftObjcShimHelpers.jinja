///
/// Copyright (c) 2024 Dropbox, Inc. All rights reserved.
///
/// Auto-generated by Stone, do not modify.
///

import Foundation
import stone_sdk_objc
import stone_sdk_swift
import stone_sdk_swift_objc

@objc
public class SDKShimHelpers: NSObject {
    // MARK: DBAPIRpcTask

    @objc public static func setResponseBlockRPC(block: @escaping DBRpcResponseBlockImpl, on task: DBXRequest, with queue: OperationQueue?) -> Bool {
        {% for namespace in namespaces | selectattr('name', '!=', 'team') %}
        {% for route in namespace.routes %}
        {% if route.attrs.get('style') == 'rpc' and ('user' in route.attrs.get('auth') or 'noauth' in route.attrs.get('auth')) and not route.deprecated %}
        {% set objc_request_class = fmt_route_objc_class(namespace, route, None) %}
        {% set objc_result_mapper = objc_to_legacy_objc_mapper(route.result_data_type, 'result') %}
        {% set objc_error_mapper = objc_to_legacy_objc_mapper(route.error_data_type, 'routeError') %}
        if let task = task as? {{ objc_request_class }} {
            {% if route.result_data_type.name == 'Void' and route.error_data_type.name == 'Void' %}
            task.response { networkError in
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(networkError == nil ? DBNilObject() : nil, nil, mappedCallError) }
            {% elif route.result_data_type.name == 'Void' %}
            task.response { routeError, networkError in
                let mappedError = {{ objc_error_mapper }}
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block((networkError == nil && routeError == nil) ? DBNilObject() : nil, mappedError, mappedCallError) }
            {% elif route.error_data_type.name == 'Void' %}
            task.response { result, networkError in
                let mappedResult = {{ objc_result_mapper }}
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, nil, mappedCallError) }
            {% else %}
            task.response { result, routeError, networkError in
                let mappedResult = {{ objc_result_mapper }}
                let mappedError = {{ objc_error_mapper }}
                let mappedCallError = callErrorToDB(error: networkError)
                let wrappedBlock = { block(mappedResult, mappedError, mappedCallError) }
            {% endif %}
                Self.processCompletion(wrappedBlock, queue: queue)
            }
            return true
        }
        {% endif %}
        {% endfor %}
        {% endfor %}
        return false
    }

    private static func processCompletion(_ wrappedBlock: @escaping () -> Void, queue: OperationQueue?) {
        if let queue = queue {
            queue.addOperation(wrappedBlock)
        } else {
            wrappedBlock()
        }
    }

    // MARK: DBAPITransportClient

    @objc public static func rpcRequest(for route: DBRoute, args: DBSerializable, userId: String, client: DBXDropboxClient) -> DBXRequest? {
        // Make sure this handles versioned routes properly
        let qualifiedRouteName = route.namespace_ + "/" + route.name
        {% for namespace in namespaces | selectattr('name', '!=', 'team') %}
        {% for route in namespace.routes %}
        {% if route.attrs.get('style') == 'rpc' and ('user' in route.attrs.get('auth') or 'noauth' in route.attrs.get('auth')) and not route.deprecated %}
        {% set func_name = fmt_func(route.name, route.version) %}
        {% set objc_data_type = fmt_objc_type(route.result_data_type) %}
        {% set route_args_no_defaults = route_args(namespace, route, None, True, False) %}
        {% set route_args = route_args(namespace, route, None, True) %}
        if qualifiedRouteName == "{{ fmt_route_name_namespace(route, namespace.name) }}"{{ shim_rpc_function_arg(route.arg_data_type) }} {
            {% if is_struct_type(route.arg_data_type) %}
            return client.{{ fmt_var(namespace.name) }}.{{ func_name }}({{ shim_legacy_objc_init_args_to_objc(route.arg_data_type, 'args', None) }})
            {% elif is_union_type(route.arg_data_type) %}
            return client.{{ fmt_var(namespace.name) }}.{{ func_name }}({{ fmt_var(route.arg_data_type.name) }}: map{{ fmt_class_prefix(route.arg_data_type) }}toDBX(object: {{ fmt_var(route.arg_data_type.name) }}))
            {% else %}
            return client.{{ fmt_var(namespace.name) }}.{{ func_name }}()
            {% endif %}
        }
        {% endif %}
        {% endfor %}
        {% endfor %}
        return nil
    }
}

private func callErrorToDB(error: DBXCallError?) -> DBRequestError? {
    if let error = error?.asInternalServerError {
        return DBRequestError(asInternalServerError: error.requestId, statusCode: NSNumber(value: error.code), errorContent: error.message, userMessage: nil)
    }
    if let error = error?.asBadInputError {
        return DBRequestError(asBadInputError: error.requestId, statusCode: NSNumber(value: 400), errorContent: nil, userMessage: nil)
    }
    if let error = error?.asAuthError {
        var localizedUserMessage: DBLocalizedUserMessage? = nil
        if let lum = error.localizedUserMessage {
            localizedUserMessage = DBLocalizedUserMessage(text: lum.text, locale: lum.locale)
        }
        var structuredAuthError: DBAUTHAuthError = {
            if error.error.asInvalidAccessToken != nil {
                return DBAUTHAuthError(invalidAccessToken: ())
            } else if error.error.asInvalidSelectUser != nil {
                return DBAUTHAuthError(invalidSelectUser: ())
            } else if error.error.asInvalidSelectAdmin != nil {
                return DBAUTHAuthError(invalidSelectAdmin: ())
            } else if error.error.asUserSuspended != nil {
                return DBAUTHAuthError(userSuspended: ())
            } else if error.error.asExpiredAccessToken != nil {
                return DBAUTHAuthError(expiredAccessToken: ())
            } else if let error = error.error.asMissingScope {
                let scopeError = DBAUTHTokenScopeError(requiredScope: error.missingScope.requiredScope)
                return DBAUTHAuthError(missingScope: scopeError)
            } else if error.error.asRouteAccessDenied != nil {
                return DBAUTHAuthError(routeAccessDenied: ())
            } else if error.error.asNoTeamApiAccess != nil {
                return DBAUTHAuthError(noTeamApiAccess: ())
            } else if error.error.asInvalidTeamAuthHeader != nil {
                return DBAUTHAuthError(invalidTeamAuthHeader: ())
            } else if error.error.asFederationAccessDenied != nil {
                return DBAUTHAuthError(federationAccessDenied: ())
            } else {
                return DBAUTHAuthError(other: ())
            }
        }()
        return DBRequestError(asAuthError: error.requestId, statusCode: NSNumber(value: 401), errorContent: error.message, userMessage: localizedUserMessage, structuredAuthError: structuredAuthError)
    }
    if let error = error?.asAccessError {
        var localizedUserMessage: DBLocalizedUserMessage? = nil
        if let lum = error.localizedUserMessage {
            localizedUserMessage = DBLocalizedUserMessage(text: lum.text, locale: lum.locale)
        }
        var structuredAccessError: DBAUTHAccessError = {
            if let error = error.error.asInvalidAccountType {
                let accountTypeError: DBAUTHInvalidAccountTypeError = {
                    if let error = error.invalidAccountType.asFeature {
                        return DBAUTHInvalidAccountTypeError(feature: ())
                    } else if let error = error.invalidAccountType.asEndpoint {
                        return DBAUTHInvalidAccountTypeError(endpoint: ())
                    } else {
                        return DBAUTHInvalidAccountTypeError(other: ())
                    }
                }()

                return DBAUTHAccessError(invalidAccountType: accountTypeError)
            } else if let error = error.error.asPaperAccessDenied {
                let paperAccessError: DBAUTHPaperAccessError = {
                    if let error = error.paperAccessDenied.asNotPaperUser {
                        return DBAUTHPaperAccessError(notPaperUser: ())
                    } else if let error = error.paperAccessDenied.asPaperDisabled {
                        return DBAUTHPaperAccessError(paperDisabled: ())
                    } else {
                        return DBAUTHPaperAccessError(other: ())
                    }
                }()
                return DBAUTHAccessError(paperAccessDenied: paperAccessError)
            } else if let error = error.error.asTeamAccessDenied {
                return DBAUTHAccessError(teamAccessDenied: ())
            } else if let error = error.error.asNoPermission {
                let noPermissionError: DBAUTHNoPermissionError = {
                    if let error = error.noPermission.asUnauthorizedAccountIdUsage {
                        let error: DBAUTHUnauthorizedAccountIdUsageError = .init(unauthorizedAccountIds: error.unauthorizedAccountIdUsage.unauthorizedAccountIds)
                        return DBAUTHNoPermissionError(unauthorizedAccountIdUsage: error)
                    } else {
                        return DBAUTHNoPermissionError(other: ())
                    }
                }()
                return DBAUTHAccessError(noPermission: noPermissionError)
            } else if let error = error.error.asPpAccessDenied {
                return DBAUTHAccessError(ppAccessDenied: ())
            } else {
                return DBAUTHAccessError(other: ())
            }
        }()
        return DBRequestError(asAccessError: error.requestId, statusCode: NSNumber(value: 403), errorContent: error.message, userMessage: localizedUserMessage, structuredAccessError: structuredAccessError)
    }
    if let error = error?.asHttpError {
        return DBRequestError(asHttpError: error.requestId, statusCode: NSNumber(value: error.code), errorContent: error.message, userMessage: nil)
    }
    if let error = error?.asRateLimitError {
        var localizedUserMessage: DBLocalizedUserMessage? = nil
        if let lum = error.localizedUserMessage {
            localizedUserMessage = DBLocalizedUserMessage(text: lum.text, locale: lum.locale)
        }
        var reason: DBAUTHRateLimitReason = {
            if let error = error.error.reason.asTooManyRequests {
                DBAUTHRateLimitReason(tooManyRequests: ())
            } else if let error = error.error.reason.asTooManyWriteOperations {
                DBAUTHRateLimitReason(tooManyWriteOperations: ())
            } else {
                DBAUTHRateLimitReason(other: ())
            }
        }()

        let structuredRateLimitError: DBAUTHRateLimitError = .init(reason: reason, retryAfter: error.error.retryAfter)

        return DBRequestError(asRateLimitError: error.requestId, statusCode: NSNumber(value: 429), errorContent: error.message, userMessage: localizedUserMessage, structuredRateLimitError: structuredRateLimitError, backoff: structuredRateLimitError.retryAfter)
    }
    if let error = error?.asSerializationError {
        return DBRequestError(asClientError: error.error)
    }
    if let error = error?.asReconnectionError {
        return DBRequestError(asClientError: error.error)
    }
    if let error = error?.asClientError {
        return DBRequestError(asClientError: error.error)
    }
    return nil
}
